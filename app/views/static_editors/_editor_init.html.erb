<script>
$().ready(function(){

var container,
    camera,
    scene,
    renderer,
    projector,
    plane,
    mouse2D,
    mouse3D,
    raycaster,
    theta = 45,
    isShiftDown = false,
    isCtrlDown = false,
    target = new THREE.Vector3( 0, 200, 0 ),
    normalMatrix = new THREE.Matrix3(),
    ROLLOVERED;

init();
animate();

function init() {

  container = document.getElementById('container');
  var $container = $(container);

  //ウィンドウ全体
  var W = window.innerWidth;
  var H = window.innerHeight;
  H = W * (800/1280);
  console.log('innerW,H', W, H);
  camera = new THREE.PerspectiveCamera( 40, W/H, 1, 10000 );
  camera.position.y = 800;
  scene = new THREE.Scene();

  scene.add( MYTHREE.getGrid() );
  projector = new THREE.Projector();
  scene.add( MYTHREE.getRayHitPlane() );
  mouse2D = new THREE.Vector3( 0, 10000, 0.5 );
  scene.add( new THREE.AmbientLight( 0x606060 ));
  scene.add( MYTHREE.getDirectionalLight() );

  renderer = new MYTHREE.getRenderer();
  container.appendChild(renderer.domElement); //<canvas>
  $('canvas').attr('id', 'canvas_id')

  document.addEventListener( 'mousemove', onDocumentMouseMove, false );
  document.addEventListener( 'mousedown', onDocumentMouseDown, false );
  document.addEventListener( 'keydown', onDocumentKeyDown, false );
  document.addEventListener( 'keyup', onDocumentKeyUp, false );
}

function onDocumentMouseMove( event ) {
  event.preventDefault();

  mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  //console.log("mouse X, Y", mouse2D.x, mouse2D.y); //0.3 etc

  var intersects = raycaster.intersectObjects( scene.children );

  if ( intersects.length > 0 ) {
    if ( ROLLOVERED ) ROLLOVERED.color.setHex( 0x00ff80 );
    ROLLOVERED = intersects[ 0 ].face;
    ROLLOVERED.color.setHex( 0xff8000 )
  }
}

function onDocumentMouseDown( event ) {
  event.preventDefault();
  var intersects = raycaster.intersectObjects( scene.children );

        if ( intersects.length > 0 ) {
          //レイとの交差点
          var intersect = intersects[ 0 ];
          console.log('intersect.point', intersect.point);
          if ( isCtrlDown ) {
            //remove voxel from scene
            if ( intersect.object != plane ) {
              scene.remove( intersect.object );
            }
          } 
          else {
            //add voxel to scene
            normalMatrix.getNormalMatrix( intersect.object.matrixWorld );

            var normal = intersect.face.normal.clone();
            normal.applyMatrix3( normalMatrix ).normalize();

            var position = new THREE.Vector3().addVectors( intersect.point, normal );

            var geometry = new THREE.CubeGeometry( 50, 50, 50 );

            for ( var i = 0; i < geometry.faces.length; i ++ ) {
              geometry.faces[ i ].color.setHex( 0x00ff80 );
            }

            var material = new THREE.MeshLambertMaterial( { vertexColors: THREE.FaceColors } );

            var voxel = new THREE.Mesh( geometry, material );
            voxel.position.x = Math.floor( position.x / 50 ) * 50 + 25;
            voxel.position.y = Math.floor( position.y / 50 ) * 50 + 25;
            voxel.position.z = Math.floor( position.z / 50 ) * 50 + 25;
            voxel.matrixAutoUpdate = false;
            voxel.updateMatrix();
            scene.add( voxel );
          }
        }
      }

      function onDocumentKeyDown( event ) {
        switch( event.keyCode ) {
          case 16: isShiftDown = true; break;
          case 17: isCtrlDown = true; break;
        }
      }

      function onDocumentKeyUp( event ) {
        switch( event.keyCode ) {
          case 16: isShiftDown = false; break;
          case 17: isCtrlDown = false; break;
        }
      }

      function save() {
        window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );
        return false;
      }

      function animate() {
        requestAnimationFrame( animate );
        render();
      }

      function render() {
        if ( isShiftDown ) {
          theta += mouse2D.x * 3;
        }

        camera.position.x = 1400 * Math.sin( theta * Math.PI / 360 );
        camera.position.z = 1400 * Math.cos( theta * Math.PI / 360 );
        camera.lookAt( target );

        raycaster = projector.pickingRay( mouse2D.clone(), camera );
        renderer.render( scene, camera );
      }

});
</script>